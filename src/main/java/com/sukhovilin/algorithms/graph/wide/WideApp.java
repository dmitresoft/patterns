package com.sukhovilin.algorithms.graph.wide;

/**
 * Обход в ширину
 * Данный алгоритм, как и обход в глубину, является одним наиболее простых и базовых методов обхода графа.
 * Его суть в том, что у нас есть некоторая текущая вершина, с которой мы все смежные, непройденные вершины,
 * заносим в очередь и выбираем следующий элемент (который хранится первым в очереди), чтобы его сделать текущим…
 * <p>
 * Если разбить данный алгоритм на этапы, можно выделить следующие правила:
 * <p>
 * Посетить следующую, ранее не посещенную вершину, смежную с текущей вершиной, пометить её заранее и занести в очередь.
 * Если выполнение правила #1 невозможно — извлечь вершину из очереди и сделать её текущей вершиной.
 * Если правило #1 и #2 невозможно, обход закончен, а все вершины пройдены (если граф у нас связный).
 */
public class WideApp {
    public static void main(String[] args) {
        Graph graph = new Graph();
        graph.addVertex('A'); //0
        graph.addVertex('B'); //1
        graph.addVertex('C'); //2
        graph.addVertex('D'); //3
        graph.addVertex('E'); //4
        graph.addVertex('F'); //5
        graph.addVertex('G'); //6

        graph.addEdge(0, 1);
        graph.addEdge(0, 2);
        graph.addEdge(0, 3);
        graph.addEdge(1, 4);
        graph.addEdge(3, 5);
        graph.addEdge(5, 6);

        System.out.println("Visits: ");
        graph.bfc();
    }
}
